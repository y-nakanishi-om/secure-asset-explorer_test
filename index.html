<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Secure Asset Explorer - Lite V6 (JP)</title>
    <meta name="theme-color" content="#0f172a">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Noto Sans JP', sans-serif; background-color: #020617; color: #e2e8f0; overflow: hidden; }
        
        /* Custom Scrollbar */
        ::-webkit-scrollbar { width: 6px; height: 6px; }
        ::-webkit-scrollbar-track { background: #0f172a; }
        ::-webkit-scrollbar-thumb { background: #334155; border-radius: 4px; }

        /* Solid UI (Lightweight) */
        .solid-panel {
            background: #0f172a;
            border-bottom: 1px solid #1e293b;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
        }
        
        .floating-panel {
            background: #1e293b;
            border: 1px solid #334155;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.5);
        }

        /* Asset Grid */
        .asset-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: 0.75rem;
            padding-bottom: 120px;
        }
        @media (min-width: 768px) { .asset-grid { grid-template-columns: repeat(auto-fill, minmax(160px, 1fr)); gap: 1rem; } }

        .asset-card { 
            position: relative;
            background-color: #1e293b; 
            border: 1px solid #334155;
            border-radius: 0.5rem;
            overflow: hidden;
            aspect-ratio: 3/4;
            cursor: pointer;
        }
        .asset-card.selected { border-color: #6366f1; box-shadow: 0 0 0 2px #6366f1; }

        /* Viewer */
        .viewer-container { display: flex; align-items: center; justify-content: center; width: 100%; height: 100%; overflow: hidden; background: #000; }
        .viewer-content { max-width: 100%; max-height: 100%; object-fit: contain; }
        
        .toast { animation: fadeIn 0.2s ease-out forwards; }
        @keyframes fadeIn { from { opacity: 0; transform: translate(-50%, 10px); } to { opacity: 1; transform: translate(-50%, 0); } }
    </style>
</head>
<body class="h-screen w-screen flex flex-col text-slate-200">

    <!-- Global Loader -->
    <div id="globalLoader" class="fixed inset-0 z-[100] bg-slate-900 flex flex-col items-center justify-center hidden">
        <div class="w-12 h-12 border-4 border-slate-700 border-t-indigo-500 rounded-full animate-spin"></div>
        <p id="loaderMsg" class="mt-4 text-xs font-bold tracking-widest text-slate-400">処理中...</p>
    </div>

    <!-- Auth Screen -->
    <div id="authScreen" class="fixed inset-0 z-50 bg-slate-950 flex flex-col items-center justify-center p-6">
        <div class="w-full max-w-sm space-y-6 text-center">
            <h1 class="text-2xl font-black tracking-tight text-white">SECURE<span class="text-indigo-500">VAULT</span> <span class="text-xs text-slate-600">Lite v6</span></h1>
            
            <div id="loginForm" class="space-y-3">
                <input type="password" id="masterPass" class="w-full bg-slate-900 border border-slate-800 text-center text-white text-lg rounded-lg py-4 px-4 focus:border-indigo-500 outline-none transition-colors" placeholder="パスワード">
                <button onclick="app.login()" class="w-full bg-indigo-600 hover:bg-indigo-500 text-white font-bold py-4 rounded-lg shadow-lg active:scale-[0.98] text-sm">ロック解除</button>
                <div class="pt-2">
                    <button onclick="ui.toggleCreateAccount()" class="text-xs text-slate-500 hover:text-white underline">初期化 / 新規作成</button>
                </div>
            </div>

            <div id="createForm" class="hidden space-y-3">
                <p class="text-xs text-red-400 font-bold">※パスワードを忘れるとデータは復旧できません</p>
                <input type="password" id="newPass" class="w-full bg-slate-900 border border-slate-800 text-center text-white rounded-lg py-3 px-4 focus:border-indigo-500 outline-none" placeholder="新しいパスワード">
                <input type="password" id="confirmPass" class="w-full bg-slate-900 border border-slate-800 text-center text-white rounded-lg py-3 px-4 focus:border-indigo-500 outline-none" placeholder="確認用再入力">
                <div class="flex gap-2">
                    <button onclick="ui.toggleCreateAccount()" class="flex-1 bg-slate-800 text-slate-300 py-3 rounded-lg text-xs font-bold">戻る</button>
                    <button onclick="app.createAccount()" class="flex-1 bg-indigo-600 text-white py-3 rounded-lg text-xs font-bold">作成実行</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Main App -->
    <div id="appInterface" class="flex-1 flex flex-col h-full opacity-0 pointer-events-none transition-opacity duration-300">
        <!-- Header -->
        <header class="solid-panel sticky top-0 z-30 px-4 py-3 flex justify-between items-center h-16">
            <div class="flex items-center gap-3">
                <div class="w-8 h-8 bg-indigo-600 rounded flex items-center justify-center">
                    <svg class="w-5 h-5 text-white" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-width="2" d="M12 15v2m-6 4h12a2 2 0 002-2v-6a2 2 0 00-2-2H6a2 2 0 00-2 2v6a2 2 0 002 2zm10-10V7a4 4 0 00-8 0v4h8z"/></svg>
                </div>
                <div class="leading-tight">
                    <h2 class="font-bold text-sm text-white">保管庫 Lite</h2>
                    <p id="itemCount" class="text-[10px] text-slate-400">読み込み中...</p>
                </div>
            </div>
            
            <div class="flex items-center gap-2">
                 <input type="text" id="searchInput" oninput="app.filter()" placeholder="検索" class="bg-slate-800 border border-slate-700 rounded-lg px-3 py-1.5 text-xs text-white outline-none focus:border-indigo-500 w-24 focus:w-32 transition-all">
                <button onclick="app.lock()" class="p-2 text-slate-400 hover:text-white bg-slate-800 rounded-lg"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-width="2" d="M17 16l4-4m0 0l-4-4m4 4H7m6 4v1a3 3 0 01-3 3H6a3 3 0 01-3-3V7a3 3 0 013-3h4a3 3 0 013 3v1" /></svg></button>
            </div>
        </header>

        <!-- Content Area -->
        <main class="flex-1 overflow-y-auto overflow-x-hidden p-4 bg-slate-950" id="mainScroll">
            <div id="gridContainer" class="asset-grid"></div>
            
            <div id="emptyState" class="hidden h-64 flex flex-col items-center justify-center text-slate-700">
                <p class="text-xs font-bold tracking-widest">データがありません</p>
            </div>
        </main>

        <!-- Bottom Actions -->
        <div class="floating-panel fixed bottom-6 left-1/2 -translate-x-1/2 rounded-full px-4 py-2 flex items-center gap-4 z-30">
            <button onclick="document.getElementById('fileInput').click()" class="text-indigo-400 hover:text-white flex flex-col items-center gap-1">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-width="2" d="M12 4v16m8-8H4"/></svg>
                <span class="text-[9px] font-bold">追加</span>
            </button>
            <div class="w-px h-6 bg-slate-700"></div>
            <button onclick="ui.toggleSelectionMode()" id="selectBtn" class="text-slate-400 hover:text-white flex flex-col items-center gap-1">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"/></svg>
                <span class="text-[9px] font-bold">選択</span>
            </button>
            
            <div id="selectionActions" class="hidden flex items-center gap-4 border-l border-slate-700 pl-4">
                 <button onclick="app.deleteSelected()" class="text-red-400 hover:text-red-200 flex flex-col items-center gap-1">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"/></svg>
                    <span class="text-[9px] font-bold">削除</span>
                 </button>
            </div>
        </div>
        
        <input type="file" id="fileInput" multiple accept="image/*,application/pdf" class="hidden" onchange="app.handleUpload(this)">
    </div>

    <!-- Viewer Modal -->
    <div id="viewer" class="fixed inset-0 z-40 bg-black hidden flex-col">
        <div class="absolute top-0 left-0 right-0 p-4 flex justify-between z-50 bg-black/50">
            <button onclick="ui.closeViewer()" class="p-2 bg-slate-800 rounded-full"><svg class="w-6 h-6 text-white" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-width="2" d="M6 18L18 6M6 6l12 12"/></svg></button>
            <div class="text-white text-xs font-mono self-center px-4" id="viewerFileName"></div>
        </div>
        <div class="viewer-container" id="viewerContainer"></div>
    </div>

    <!-- Toast -->
    <div id="toast" class="fixed bottom-24 left-1/2 -translate-x-1/2 bg-slate-800 text-white px-6 py-3 rounded-lg shadow-xl font-bold text-xs z-[100] hidden whitespace-nowrap border border-slate-700"></div>

    <script>
        /* V6 LITE EDITION
           - Web Worker廃止（互換性重視）
           - 重いCSS演出の削除
           - V6のDB設計（メタデータ分離）は維持
        */

        // --- CRYPTO UTILS (MAIN THREAD) ---
        // UIフリーズを防ぐため、PromiseでラップしsetTimeoutでイベントループを回す
        const asyncCrypto = async (action, payload, secret, salt = null, iterations = null) => {
            await new Promise(r => setTimeout(r, 5)); // UI更新のために少し待機
            
            try {
                if (action === 'deriveKey') {
                    // 鍵生成は重いので、ここでのみ同期的に実行（ローディング表示済み前提）
                    return CryptoJS.PBKDF2(payload, salt, { keySize: 256/32, iterations: 5000 }).toString(); // 反復回数を5000に調整
                } 
                else if (action === 'encrypt') {
                    const iv = CryptoJS.lib.WordArray.random(128/8);
                    const encrypted = CryptoJS.AES.encrypt(payload, secret, { iv: iv });
                    return iv.toString() + ":" + encrypted.toString();
                }
                else if (action === 'decrypt') {
                    const parts = payload.split(":");
                    if (parts.length < 2) throw new Error("Invalid format");
                    const iv = CryptoJS.enc.Hex.parse(parts[0]);
                    const bytes = CryptoJS.AES.decrypt(parts[1], secret, { iv: iv });
                    const str = bytes.toString(CryptoJS.enc.Utf8);
                    // 【修正】空文字（サムネイルなし等）は正常として許可する
                    if (str === "" && payload) return str; 
                    if (!str && str !== "") throw new Error("Decryption failed");
                    return str;
                }
            } catch (e) {
                console.error("Crypto Error:", e);
                throw e;
            }
        };

        // --- CONSTANTS ---
        const DB_NAME = "Vault_Pro_v6";
        const STORES = { META: 'assets_meta', DATA: 'assets_content', CONFIG: 'config' };
        
        const state = {
            db: null,
            key: null,
            userId: null,
            assets: [],
            selected: new Set(),
            isSelectionMode: false
        };

        // --- DATABASE ---
        const dbMgr = {
            init: () => {
                return new Promise((resolve, reject) => {
                    const req = indexedDB.open(DB_NAME, 6);
                    req.onupgradeneeded = (e) => {
                        const db = e.target.result;
                        if (!db.objectStoreNames.contains(STORES.CONFIG)) db.createObjectStore(STORES.CONFIG, { keyPath: 'key' });
                        if (!db.objectStoreNames.contains(STORES.META)) {
                            const metaStore = db.createObjectStore(STORES.META, { keyPath: 'id' });
                            metaStore.createIndex('ownerId', 'ownerId', { unique: false });
                        }
                        if (!db.objectStoreNames.contains(STORES.DATA)) {
                            db.createObjectStore(STORES.DATA, { keyPath: 'id' });
                        }
                    };
                    req.onsuccess = (e) => { state.db = e.target.result; resolve(); };
                    req.onerror = reject;
                });
            },
            getMeta: async (userId) => {
                return new Promise(resolve => {
                    const tx = state.db.transaction(STORES.META, 'readonly');
                    const index = tx.objectStore(STORES.META).index('ownerId');
                    const req = index.getAll(userId);
                    req.onsuccess = () => resolve(req.result);
                    req.onerror = () => resolve([]);
                });
            },
            getContent: async (id) => {
                return new Promise((resolve, reject) => {
                    const tx = state.db.transaction(STORES.DATA, 'readonly');
                    const req = tx.objectStore(STORES.DATA).get(id);
                    req.onsuccess = () => resolve(req.result ? req.result.content : null);
                    req.onerror = reject;
                });
            },
            saveAsset: async (meta, content) => {
                return new Promise((resolve, reject) => {
                    const tx = state.db.transaction([STORES.META, STORES.DATA], 'readwrite');
                    tx.objectStore(STORES.META).put(meta);
                    tx.objectStore(STORES.DATA).put({ id: meta.id, content: content });
                    tx.oncomplete = resolve;
                    tx.onerror = reject;
                });
            },
            deleteAsset: async (id) => {
                const tx = state.db.transaction([STORES.META, STORES.DATA], 'readwrite');
                tx.objectStore(STORES.META).delete(id);
                tx.objectStore(STORES.DATA).delete(id);
                return new Promise(r => tx.oncomplete = r);
            }
        };

        // --- APP LOGIC ---
        const app = {
            init: async () => {
                await dbMgr.init();
            },
            
            login: async () => {
                const pass = document.getElementById('masterPass').value;
                if(pass.length < 4) return ui.toast("パスワードが短すぎます");
                
                ui.loader(true, "認証処理中...");
                // UI描画のために少し待つ
                setTimeout(async () => {
                    const hash = CryptoJS.SHA256(pass).toString();
                    const configKey = "cfg_" + hash;

                    try {
                        const tx = state.db.transaction(STORES.CONFIG, 'readonly');
                        const req = tx.objectStore(STORES.CONFIG).get(configKey);
                        
                        req.onsuccess = async () => {
                            const config = req.result;
                            if (!config) {
                                ui.loader(false);
                                ui.toast("保管庫が見つかりません");
                                return;
                            }

                            try {
                                const derivedKey = await asyncCrypto('deriveKey', pass, null, config.salt);
                                const decryptedTest = await asyncCrypto('decrypt', config.challenge, derivedKey);
                                
                                if (decryptedTest === "VERIFIED") {
                                    state.key = derivedKey;
                                    state.userId = hash;
                                    app.unlockInterface();
                                } else {
                                    throw new Error();
                                }
                            } catch (e) {
                                ui.loader(false);
                                ui.toast("パスワードが違います");
                                document.getElementById('masterPass').value = '';
                            }
                        };
                    } catch(e) { ui.loader(false); ui.toast("システムエラー"); }
                }, 100);
            },

            createAccount: async () => {
                const p1 = document.getElementById('newPass').value;
                const p2 = document.getElementById('confirmPass').value;
                if (p1 !== p2 || p1.length < 4) return ui.toast("パスワードが無効です");

                ui.loader(true, "保管庫を作成中...");
                setTimeout(async () => {
                    const hash = CryptoJS.SHA256(p1).toString();
                    const salt = CryptoJS.lib.WordArray.random(128/8).toString();
                    
                    const derivedKey = await asyncCrypto('deriveKey', p1, null, salt);
                    const challenge = await asyncCrypto('encrypt', "VERIFIED", derivedKey);

                    const config = { key: "cfg_" + hash, salt, challenge };
                    
                    const tx = state.db.transaction(STORES.CONFIG, 'readwrite');
                    tx.objectStore(STORES.CONFIG).put(config);
                    tx.oncomplete = () => {
                        ui.loader(false);
                        ui.toast("作成完了。ログインしてください");
                        ui.toggleCreateAccount();
                        document.getElementById('masterPass').value = '';
                    };
                }, 100);
            },

            unlockInterface: async () => {
                document.getElementById('authScreen').style.display = 'none';
                const main = document.getElementById('appInterface');
                main.classList.remove('opacity-0', 'pointer-events-none');
                await app.refreshLibrary();
                ui.loader(false);
            },

            refreshLibrary: async () => {
                state.assets = await dbMgr.getMeta(state.userId);
                state.assets.sort((a,b) => b.timestamp - a.timestamp);
                ui.renderGrid();
            },

            handleUpload: async (input) => {
                if (!input.files.length) return;
                const files = Array.from(input.files);
                ui.loader(true, "ファイルを処理中...");

                // 1つずつ直列処理してUIフリーズを回避
                for (let i = 0; i < files.length; i++) {
                    const file = files[i];
                    ui.updateLoaderMsg(`暗号化中... (${i + 1}/${files.length})`);
                    
                    try {
                        const reader = new FileReader();
                        const dataUrl = await new Promise(r => { reader.onload = e => r(e.target.result); reader.readAsDataURL(file); });

                        let thumb = "";
                        if (file.type.startsWith('image')) {
                            thumb = await utils.createThumb(dataUrl);
                        }

                        const encName = await asyncCrypto('encrypt', file.name, state.key);
                        const encType = await asyncCrypto('encrypt', file.type, state.key);
                        const encThumb = await asyncCrypto('encrypt', thumb, state.key);
                        const encData = await asyncCrypto('encrypt', dataUrl, state.key);

                        const id = crypto.randomUUID();
                        const meta = {
                            id,
                            ownerId: state.userId,
                            name: encName,
                            type: encType,
                            thumbnail: encThumb,
                            timestamp: Date.now(),
                            size: file.size
                        };

                        await dbMgr.saveAsset(meta, encData);
                    } catch (e) {
                        console.error(e);
                    }
                }

                input.value = "";
                await app.refreshLibrary();
                ui.loader(false);
                ui.toast("保存完了");
            },

            openItem: async (id) => {
                if (state.isSelectionMode) return app.toggleSelect(id);
                
                ui.loader(true, "復号して開いています...");
                setTimeout(async () => {
                    const meta = state.assets.find(a => a.id === id);
                    const encContent = await dbMgr.getContent(id);
                    
                    if (!encContent) {
                        ui.loader(false);
                        return ui.toast("データが見つかりません");
                    }

                    try {
                        const decryptedData = await asyncCrypto('decrypt', encContent, state.key);
                        const decryptedType = await asyncCrypto('decrypt', meta.type, state.key);
                        const decryptedName = await asyncCrypto('decrypt', meta.name, state.key);
                        
                        viewer.show(decryptedData, decryptedType, decryptedName);
                        ui.loader(false);
                    } catch(e) {
                        ui.loader(false);
                        ui.toast("復号エラー");
                    }
                }, 50);
            },

            lock: () => {
                location.reload(); // 最も確実なロック方法（メモリクリア）
            },
            
            toggleSelect: (id) => {
                if (state.selected.has(id)) state.selected.delete(id);
                else state.selected.add(id);
                ui.updateSelectionUI();
            },
            
            deleteSelected: async () => {
                if(!confirm(`${state.selected.size} 件を削除しますか？`)) return;
                ui.loader(true, "削除中...");
                for(let id of state.selected) await dbMgr.deleteAsset(id);
                state.selected.clear();
                ui.toggleSelectionMode();
                await app.refreshLibrary();
                ui.loader(false);
            },

            filter: () => {
                const q = document.getElementById('searchInput').value.toLowerCase();
                const grid = document.getElementById('gridContainer');
                for (let card of grid.children) {
                    const name = card.dataset.name.toLowerCase();
                    card.style.display = name.includes(q) ? 'block' : 'none';
                }
            }
        };

        // --- UI ---
        const ui = {
            loader: (show, msg) => {
                const el = document.getElementById('globalLoader');
                if (msg) document.getElementById('loaderMsg').textContent = msg;
                el.style.display = show ? 'flex' : 'none';
            },
            updateLoaderMsg: (msg) => {
                document.getElementById('loaderMsg').textContent = msg;
            },
            toast: (msg) => {
                const t = document.getElementById('toast');
                t.textContent = msg;
                // 【修正】inline-styleのdisplay設定を削除し、classList制御のみにする
                t.style.display = ''; 
                t.classList.remove('hidden');
                setTimeout(() => t.classList.add('hidden'), 3000);
            },
            toggleCreateAccount: () => {
                document.getElementById('loginForm').classList.toggle('hidden');
                document.getElementById('createForm').classList.toggle('hidden');
            },
            renderGrid: async () => {
                const grid = document.getElementById('gridContainer');
                grid.innerHTML = '';
                
                if (state.assets.length === 0) {
                    document.getElementById('emptyState').classList.remove('hidden');
                    document.getElementById('itemCount').textContent = "0 件";
                    return;
                }
                document.getElementById('emptyState').classList.add('hidden');
                document.getElementById('itemCount').textContent = `${state.assets.length} 件`;

                // バッチ処理でサムネイルを復号・描画
                for (let i = 0; i < state.assets.length; i++) {
                    const item = state.assets[i];
                    const el = document.createElement('div');
                    el.className = 'asset-card group';
                    el.dataset.id = item.id;
                    el.innerHTML = `
                        <div class="w-full h-full bg-slate-800 flex items-center justify-center text-slate-600 text-xs">
                            <span class="loading-text">...</span>
                        </div>
                        <img class="hidden w-full h-full object-cover">
                        <div class="absolute bottom-0 inset-x-0 bg-black/70 p-2 text-[10px] text-white truncate opacity-0 group-hover:opacity-100 transition-opacity">
                            <span class="name-text"></span>
                        </div>
                    `;
                    el.onclick = () => app.openItem(item.id);
                    grid.appendChild(el);

                    // 遅延復号
                    Promise.all([
                        asyncCrypto('decrypt', item.thumbnail, state.key),
                        asyncCrypto('decrypt', item.name, state.key)
                    ]).then(([thumbSrc, nameStr]) => {
                        const img = el.querySelector('img');
                        if (thumbSrc) {
                            img.src = thumbSrc;
                            img.classList.remove('hidden');
                            el.querySelector('.loading-text').parentElement.classList.add('hidden');
                        } else {
                            // サムネイルなし（PDF等）の場合のフォールバック表示
                            el.querySelector('.loading-text').textContent = "FILE";
                        }
                        el.querySelector('.name-text').textContent = nameStr;
                        el.dataset.name = nameStr;
                    }).catch(() => {
                        el.querySelector('.loading-text').textContent = "ERR";
                    });
                }
            },
            toggleSelectionMode: () => {
                state.isSelectionMode = !state.isSelectionMode;
                state.selected.clear();
                ui.updateSelectionUI();
                
                const btn = document.getElementById('selectBtn');
                btn.classList.toggle('text-indigo-400', state.isSelectionMode);
                document.getElementById('selectionActions').classList.toggle('hidden', !state.isSelectionMode);
            },
            updateSelectionUI: () => {
                for(let card of document.querySelectorAll('.asset-card')) {
                    if (state.selected.has(card.dataset.id)) card.classList.add('selected');
                    else card.classList.remove('selected');
                }
            },
            closeViewer: () => {
                document.getElementById('viewer').classList.add('hidden');
                document.getElementById('viewerContainer').innerHTML = '';
            }
        };

        const viewer = {
            show: (data, type, name) => {
                const con = document.getElementById('viewerContainer');
                con.innerHTML = '';
                document.getElementById('viewerFileName').textContent = name;
                
                if (type.startsWith('image')) {
                    const img = new Image();
                    img.src = data;
                    img.className = 'viewer-content';
                    con.appendChild(img);
                } else if (type === 'application/pdf') {
                    // 簡易PDF表示
                    const embed = document.createElement('iframe');
                    embed.src = data;
                    embed.className = 'w-full h-full border-none bg-white';
                    con.appendChild(embed);
                }
                document.getElementById('viewer').classList.remove('hidden');
            }
        };

        const utils = {
            createThumb: (src) => {
                return new Promise(resolve => {
                    const img = new Image();
                    img.onload = () => {
                        const cvs = document.createElement('canvas');
                        const dim = 200;
                        let w = img.width, h = img.height;
                        if (w > h) { h = h * (dim/w); w = dim; } else { w = w * (dim/h); h = dim; }
                        cvs.width = w; cvs.height = h;
                        cvs.getContext('2d').drawImage(img, 0, 0, w, h);
                        resolve(cvs.toDataURL('image/jpeg', 0.5));
                    };
                    img.src = src;
                });
            }
        };

        // Init
        app.init();

    </script>
</body>
</html>