<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Secure Asset Explorer - Lite V6 (Signage I/O)</title>
    <meta name="theme-color" content="#0f172a">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Noto Sans JP', sans-serif; background-color: #020617; color: #e2e8f0; overflow: hidden; }
        
        /* Custom Scrollbar */
        ::-webkit-scrollbar { width: 6px; height: 6px; }
        ::-webkit-scrollbar-track { background: #0f172a; }
        ::-webkit-scrollbar-thumb { background: #334155; border-radius: 4px; }

        /* Asset Grid */
        .asset-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: 0.75rem;
            padding-bottom: 140px;
        }
        @media (min-width: 768px) { .asset-grid { grid-template-columns: repeat(auto-fill, minmax(160px, 1fr)); gap: 1rem; } }

        .asset-card { 
            position: relative;
            background-color: #1e293b; 
            border: 1px solid #334155;
            border-radius: 0.5rem;
            overflow: hidden;
            aspect-ratio: 3/4;
            cursor: pointer;
        }
        .asset-card.selected { border-color: #6366f1; box-shadow: 0 0 0 2px #6366f1; }

        /* Viewer */
        .viewer-container { display: flex; align-items: center; justify-content: center; width: 100%; height: 100%; overflow: auto; background: #000; position: relative; }
        .viewer-content { transition: transform 0.3s ease; transform-origin: center center; max-width: 95vw; }
        .pdf-wrapper { display: flex; flex-direction: column; align-items: center; gap: 10px; padding: 20px; transition: transform 0.3s ease; }
        .pdf-page { max-width: 100%; box-shadow: 0 4px 6px rgba(0,0,0,0.3); }
        
        /* Idle Fade Effect */
        .idle-fade { transition: opacity 0.5s ease; opacity: 1; }
        #viewer.idle .idle-fade { opacity: 0.1; pointer-events: none; }
        #viewer.idle .idle-fade:hover { opacity: 1; pointer-events: auto; }

        /* Bottom Toolbar Style */
        .bottom-toolbar {
            background: rgba(15, 23, 42, 0.95);
            border: 1px solid #334155;
            box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(12px);
        }

        .toast { animation: fadeIn 0.2s ease-out forwards; }
        @keyframes fadeIn { from { opacity: 0; transform: translate(-50%, 10px); } to { opacity: 1; transform: translate(-50%, 0); } }
        .shake { animation: shake 0.2s ease-in-out 0s 2; }
        @keyframes shake { 0%, 100% { transform: translateX(0); } 25% { transform: translateX(-8px); } 75% { transform: translateX(8px); } }
    </style>
</head>
<body class="h-screen w-screen flex flex-col text-slate-200">

    <!-- Global Loader -->
    <div id="globalLoader" class="fixed inset-0 z-[100] bg-slate-900 flex flex-col items-center justify-center hidden">
        <div class="w-12 h-12 border-4 border-slate-700 border-t-indigo-500 rounded-full animate-spin"></div>
        <p id="loaderMsg" class="mt-4 text-xs font-bold tracking-widest text-slate-400">処理中...</p>
    </div>

    <!-- Auth Screen -->
    <div id="authScreen" class="fixed inset-0 z-50 bg-slate-950 flex flex-col items-center justify-center p-6">
        <div class="w-full max-w-sm space-y-6 text-center">
            <h1 class="text-2xl font-black tracking-tight text-white">SECURE<span class="text-indigo-500">VAULT</span> <span class="text-xs text-slate-600">Lite v6</span></h1>
            
            <div id="loginForm" class="space-y-4">
                <input type="password" id="masterPass" class="w-full bg-slate-900 border border-slate-800 text-center text-white text-lg rounded-lg py-4 px-4 focus:border-indigo-500 outline-none transition-colors" placeholder="パスワード">
                <button onclick="app.login()" class="w-full bg-indigo-600 hover:bg-indigo-500 text-white font-bold py-4 rounded-lg shadow-lg active:scale-[0.98] text-sm">ロック解除</button>
                <div class="pt-4 flex flex-col gap-2">
                    <button onclick="ui.toggleCreateAccount()" class="text-xs text-slate-500 hover:text-white underline">新規作成</button>
                    <button onclick="app.resetSystem()" class="text-[10px] text-red-900 hover:text-red-500 font-bold tracking-widest mt-4">⚠ システム初期化 (データ全消去)</button>
                </div>
            </div>

            <div id="createForm" class="hidden space-y-3">
                <p class="text-xs text-red-400 font-bold">※パスワードを忘れるとデータは復旧できません</p>
                <input type="password" id="newPass" class="w-full bg-slate-900 border border-slate-800 text-center text-white rounded-lg py-3 px-4 focus:border-indigo-500 outline-none" placeholder="新しいパスワード">
                <input type="password" id="confirmPass" class="w-full bg-slate-900 border border-slate-800 text-center text-white rounded-lg py-3 px-4 focus:border-indigo-500 outline-none" placeholder="確認用再入力">
                <div class="flex gap-2">
                    <button onclick="ui.toggleCreateAccount()" class="flex-1 bg-slate-800 text-slate-300 py-3 rounded-lg text-xs font-bold">戻る</button>
                    <button onclick="app.createAccount()" class="flex-1 bg-indigo-600 text-white py-3 rounded-lg text-xs font-bold">作成実行</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Main App -->
    <div id="appInterface" class="flex-1 flex flex-col h-full opacity-0 pointer-events-none transition-opacity duration-300">
        <!-- Header -->
        <header class="solid-panel sticky top-0 z-30 px-4 py-3 flex justify-between items-center h-16">
            <div class="flex items-center gap-3">
                <div class="w-8 h-8 bg-indigo-600 rounded flex items-center justify-center">
                    <svg class="w-5 h-5 text-white" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-width="2" d="M12 15v2m-6 4h12a2 2 0 002-2v-6a2 2 0 00-2-2H6a2 2 0 00-2 2v6a2 2 0 002 2zm10-10V7a4 4 0 00-8 0v4h8z"/></svg>
                </div>
                <div class="leading-tight">
                    <h2 class="font-bold text-sm text-white">保管庫 Lite</h2>
                    <p id="itemCount" class="text-[10px] text-slate-400">読み込み中...</p>
                </div>
            </div>
            
            <div class="flex items-center gap-2">
                 <input type="text" id="searchInput" oninput="app.filter()" placeholder="検索" class="bg-slate-800 border border-slate-700 rounded-lg px-3 py-1.5 text-xs text-white outline-none focus:border-indigo-500 w-24 focus:w-32 transition-all">
                <button onclick="app.lock()" class="p-2 text-slate-400 hover:text-white bg-slate-800 rounded-lg" title="ロック"><svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-width="2" d="M17 16l4-4m0 0l-4-4m4 4H7m6 4v1a3 3 0 01-3 3H6a3 3 0 01-3-3V7a3 3 0 013-3h4a3 3 0 013 3v1" /></svg></button>
            </div>
        </header>

        <!-- Content Area -->
        <main class="flex-1 overflow-y-auto overflow-x-hidden p-4 bg-slate-950" id="mainScroll">
            <div id="gridContainer" class="asset-grid"></div>
            
            <div id="emptyState" class="hidden h-64 flex flex-col items-center justify-center text-slate-700">
                <p class="text-xs font-bold tracking-widest">データがありません</p>
            </div>
        </main>

        <!-- Bottom Integrated Toolbar -->
        <div class="fixed bottom-6 left-4 right-4 z-30 flex justify-center pointer-events-none">
            <div class="bottom-toolbar pointer-events-auto px-6 py-3 flex flex-wrap justify-center items-center gap-6 rounded-2xl">
                
                <!-- Main Actions -->
                <button onclick="document.getElementById('fileInput').click()" class="text-indigo-400 hover:text-white flex flex-col items-center gap-1 transition-colors">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-width="2" d="M12 4v16m8-8H4"/></svg>
                    <span class="text-[9px] font-bold">追加</span>
                </button>

                <div class="w-px h-6 bg-slate-700"></div>

                <!-- I/O Buttons -->
                <button onclick="document.getElementById('importJsonInput').click()" class="text-emerald-400 hover:text-white flex flex-col items-center gap-1 transition-colors">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12"/></svg>
                    <span class="text-[9px] font-bold">読込</span>
                </button>

                <button onclick="app.exportBackup()" class="text-sky-400 hover:text-white flex flex-col items-center gap-1 transition-colors">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"/></svg>
                    <span class="text-[9px] font-bold">書出</span>
                </button>
                
                <div class="w-px h-6 bg-slate-700"></div>

                <button onclick="ui.toggleSelectionMode()" id="selectBtn" class="text-slate-400 hover:text-white flex flex-col items-center gap-1 transition-colors">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"/></svg>
                    <span class="text-[9px] font-bold">選択</span>
                </button>

                <div id="selectionActions" class="hidden flex items-center">
                     <button onclick="app.deleteSelected()" class="text-red-400 hover:text-red-200 flex flex-col items-center gap-1 transition-colors">
                        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"/></svg>
                        <span class="text-[9px] font-bold">削除</span>
                     </button>
                </div>

                <!-- Divider -->
                <div class="h-8 w-px bg-slate-700"></div>

                <!-- Info -->
                <div class="hidden sm:block">
                    <p id="itemCountDisplay" class="text-[10px] text-slate-400 font-mono">0 Items</p>
                </div>

            </div>
        </div>
        
        <input type="file" id="fileInput" multiple accept="image/*,application/pdf" class="hidden" onchange="app.handleUpload(this)">
        <input type="file" id="importJsonInput" accept=".json" class="hidden" onchange="app.handleImport(this)">
    </div>

    <!-- Viewer Modal -->
    <div id="viewer" class="fixed inset-0 z-40 bg-black hidden flex-col">
        <div class="viewer-container" id="viewerContainer"></div>

        <!-- Navigation Buttons -->
        <button onclick="viewer.nav(-1)" class="idle-fade absolute left-6 top-1/2 -translate-y-1/2 p-5 bg-slate-800/80 rounded-full hover:bg-slate-700 text-white z-50 transition-all shadow-lg backdrop-blur-sm">
            <svg class="w-8 h-8" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-width="3" d="M15 19l-7-7 7-7"/></svg>
        </button>
        <button onclick="viewer.nav(1)" class="idle-fade absolute right-6 top-1/2 -translate-y-1/2 p-5 bg-slate-800/80 rounded-full hover:bg-slate-700 text-white z-50 transition-all shadow-lg backdrop-blur-sm">
            <svg class="w-8 h-8" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-width="3" d="M9 5l7 7-7 7"/></svg>
        </button>

        <!-- Bottom Control Bar -->
        <div class="idle-fade absolute bottom-0 left-0 right-0 p-6 flex justify-center items-center z-50 pointer-events-none">
            <div class="pointer-events-auto bg-slate-900/90 backdrop-blur-md rounded-2xl border border-slate-700 p-2 flex items-center gap-4 shadow-2xl">
                <button onclick="ui.closeViewer()" class="px-6 py-3 bg-slate-800 hover:bg-slate-700 rounded-xl flex items-center gap-2 transition-colors">
                    <svg class="w-5 h-5 text-white" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-width="2.5" d="M6 18L18 6M6 6l12 12"/></svg>
                    <span class="text-white font-bold text-sm">閉じる</span>
                </button>
                
                <div class="h-8 w-px bg-slate-700"></div>
                <div class="text-white text-xs font-mono truncate px-2 max-w-[200px]" id="viewerFileName"></div>
                <div class="h-8 w-px bg-slate-700"></div>
                
                <button onclick="viewer.rotate()" class="px-6 py-3 bg-slate-800 hover:bg-slate-700 rounded-xl flex items-center gap-2 transition-colors">
                    <span class="text-white font-bold text-sm">回転</span>
                    <svg class="w-5 h-5 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-width="2.5" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"/></svg>
                </button>
            </div>
        </div>
    </div>

    <!-- Toast -->
    <div id="toast" class="fixed bottom-32 left-1/2 -translate-x-1/2 bg-slate-800 text-white px-6 py-3 rounded-lg shadow-xl font-bold text-xs z-[100] hidden whitespace-nowrap border border-slate-700"></div>

    <script>
        // PDF.js
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
        const CMAP_URL = 'https://cdn.jsdelivr.net/npm/pdfjs-dist@3.11.174/cmaps/';

        // Global Error Handler
        window.onerror = function(msg, url, line) {
            console.error("Global Error:", msg);
            document.getElementById('globalLoader').style.display = 'none';
        };

        // --- CRYPTO LOGIC ---
        const asyncCrypto = async (action, payload, secret, salt = null, iterations = 10000) => {
            await new Promise(r => setTimeout(r, 10));
            try {
                if (action === 'deriveKey') {
                    return CryptoJS.PBKDF2(payload, salt, { keySize: 256/32, iterations: iterations });
                } 
                else if (action === 'encrypt') {
                    const iv = CryptoJS.lib.WordArray.random(128/8);
                    const encrypted = CryptoJS.AES.encrypt(payload, secret, { iv: iv });
                    return iv.toString() + ":" + encrypted.toString();
                }
                else if (action === 'decrypt') {
                    const parts = payload.split(":");
                    if (parts.length < 2) return null;
                    const iv = CryptoJS.enc.Hex.parse(parts[0]);
                    const bytes = CryptoJS.AES.decrypt(parts[1], secret, { iv: iv });
                    const str = bytes.toString(CryptoJS.enc.Utf8);
                    if (!str && str !== "") return null; 
                    return str;
                }
            } catch (e) {
                console.error("Crypto Error:", e);
                return null;
            }
        };

        // --- CONSTANTS ---
        const DB_NAME = "Vault_Pro_v6";
        const STORES = { META: 'assets_meta', DATA: 'assets_content', CONFIG: 'config' };
        
        const state = {
            db: null,
            key: null,
            userId: null,
            assets: [],
            selected: new Set(),
            isSelectionMode: false
        };

        // --- DATABASE ---
        const dbMgr = {
            init: () => {
                return new Promise((resolve, reject) => {
                    const req = indexedDB.open(DB_NAME, 6);
                    req.onupgradeneeded = (e) => {
                        const db = e.target.result;
                        if (!db.objectStoreNames.contains(STORES.CONFIG)) db.createObjectStore(STORES.CONFIG, { keyPath: 'key' });
                        if (!db.objectStoreNames.contains(STORES.META)) {
                            const metaStore = db.createObjectStore(STORES.META, { keyPath: 'id' });
                            metaStore.createIndex('ownerId', 'ownerId', { unique: false });
                        }
                        if (!db.objectStoreNames.contains(STORES.DATA)) {
                            db.createObjectStore(STORES.DATA, { keyPath: 'id' });
                        }
                    };
                    req.onsuccess = (e) => { state.db = e.target.result; resolve(); };
                    req.onerror = reject;
                });
            },
            getMeta: async (userId) => {
                return new Promise(resolve => {
                    if (!state.db) return resolve([]);
                    const tx = state.db.transaction(STORES.META, 'readonly');
                    const index = tx.objectStore(STORES.META).index('ownerId');
                    const req = index.getAll(userId);
                    req.onsuccess = () => resolve(req.result);
                    req.onerror = () => resolve([]);
                });
            },
            getContent: async (id) => {
                return new Promise((resolve, reject) => {
                    const tx = state.db.transaction(STORES.DATA, 'readonly');
                    const req = tx.objectStore(STORES.DATA).get(id);
                    req.onsuccess = () => resolve(req.result ? req.result.content : null);
                    req.onerror = reject;
                });
            },
            saveAsset: async (meta, content) => {
                return new Promise((resolve, reject) => {
                    const tx = state.db.transaction([STORES.META, STORES.DATA], 'readwrite');
                    tx.objectStore(STORES.META).put(meta);
                    tx.objectStore(STORES.DATA).put({ id: meta.id, content: content });
                    tx.oncomplete = resolve;
                    tx.onerror = reject;
                });
            },
            deleteAsset: async (id) => {
                const tx = state.db.transaction([STORES.META, STORES.DATA], 'readwrite');
                tx.objectStore(STORES.META).delete(id);
                tx.objectStore(STORES.DATA).delete(id);
                return new Promise(r => tx.oncomplete = r);
            }
        };

        // --- APP LOGIC ---
        const app = {
            init: async () => {
                try {
                    await dbMgr.init();
                } catch(e) {
                    console.error(e);
                    ui.toast("DBエラー。初期化してください。");
                }
            },
            
            login: async () => {
                const pass = document.getElementById('masterPass').value;
                if(pass.length < 4) {
                    ui.showError("パスワードが短すぎます");
                    return;
                }
                ui.loader(true, "認証処理中...");
                
                try {
                    await new Promise(r => setTimeout(r, 100));

                    const hash = CryptoJS.SHA256(pass).toString();
                    const configKey = "cfg_" + hash;

                    const tx = state.db.transaction(STORES.CONFIG, 'readonly');
                    const req = tx.objectStore(STORES.CONFIG).get(configKey);
                    
                    req.onsuccess = async () => {
                        const config = req.result;
                        if (!config) {
                            ui.loader(false);
                            ui.showError("保管庫が見つかりません");
                            return;
                        }

                        const derivedKey = await asyncCrypto('deriveKey', pass, null, config.salt);
                        const decryptedTest = await asyncCrypto('decrypt', config.challenge, derivedKey);
                        
                        if (decryptedTest === "OK") {
                            state.key = derivedKey;
                            state.userId = hash;
                            app.unlockInterface();
                        } else {
                            ui.loader(false);
                            ui.showError("パスワードが違います");
                            document.getElementById('masterPass').value = '';
                        }
                    };
                    req.onerror = () => { ui.loader(false); ui.toast("DB読み込みエラー"); };
                } catch (e) {
                    console.error("Login Error:", e);
                    ui.loader(false);
                    ui.toast("予期せぬエラー");
                }
            },

            createAccount: async () => {
                const p1 = document.getElementById('newPass').value;
                const p2 = document.getElementById('confirmPass').value;
                if (p1 !== p2 || p1.length < 4) return ui.toast("パスワードが無効です");

                ui.loader(true, "保管庫を作成中...");
                
                try {
                    await new Promise(r => setTimeout(r, 100));

                    const hash = CryptoJS.SHA256(p1).toString();
                    const txCheck = state.db.transaction(STORES.CONFIG, 'readonly');
                    const reqCheck = txCheck.objectStore(STORES.CONFIG).get("cfg_" + hash);
                    
                    reqCheck.onsuccess = async () => {
                        if (reqCheck.result) {
                            ui.loader(false);
                            ui.toast("既に存在するパスワードです");
                            return;
                        }

                        const salt = CryptoJS.lib.WordArray.random(128/8).toString();
                        const derivedKey = await asyncCrypto('deriveKey', p1, null, salt);
                        const challenge = await asyncCrypto('encrypt', "OK", derivedKey);

                        const config = { key: "cfg_" + hash, salt, challenge };
                        
                        const tx = state.db.transaction(STORES.CONFIG, 'readwrite');
                        tx.objectStore(STORES.CONFIG).put(config);
                        
                        tx.oncomplete = () => {
                            ui.loader(false);
                            ui.toast("作成完了。ログインしてください");
                            ui.toggleCreateAccount();
                            document.getElementById('masterPass').value = '';
                        };
                    };
                } catch(e) {
                    console.error("Create Error:", e);
                    ui.loader(false);
                    ui.toast("作成に失敗しました");
                }
            },

            resetSystem: () => {
                if(!confirm("【警告】すべてのデータが消去されます。\n本当によろしいですか？")) return;
                if (state.db) state.db.close();
                const req = indexedDB.deleteDatabase(DB_NAME);
                req.onsuccess = () => { alert("システムを初期化しました。"); location.reload(); };
                req.onerror = () => alert("初期化に失敗しました。");
            },

            unlockInterface: async () => {
                document.getElementById('authScreen').style.display = 'none';
                const main = document.getElementById('appInterface');
                main.classList.remove('opacity-0', 'pointer-events-none');
                await app.refreshLibrary();
                ui.loader(false);
            },

            refreshLibrary: async () => {
                state.assets = await dbMgr.getMeta(state.userId);
                state.assets.sort((a,b) => b.timestamp - a.timestamp);
                ui.renderGrid();
            },

            handleUpload: async (input) => {
                if (!input.files.length) return;
                const files = Array.from(input.files);
                ui.loader(true, "ファイルを処理中...");

                try {
                    for (let i = 0; i < files.length; i++) {
                        const file = files[i];
                        ui.updateLoaderMsg(`暗号化中... (${i + 1}/${files.length})`);
                        await new Promise(r => setTimeout(r, 10));

                        const reader = new FileReader();
                        const dataUrl = await new Promise(r => { reader.onload = e => r(e.target.result); reader.readAsDataURL(file); });

                        let thumb = "";
                        if (file.type.startsWith('image')) { thumb = await utils.createThumb(dataUrl); }
                        else if (file.type === 'application/pdf') { thumb = await utils.createPDFThumb(dataUrl); }

                        const encName = await asyncCrypto('encrypt', file.name, state.key);
                        const encType = await asyncCrypto('encrypt', file.type, state.key);
                        const encThumb = await asyncCrypto('encrypt', thumb, state.key);
                        const encData = await asyncCrypto('encrypt', dataUrl, state.key);

                        const id = crypto.randomUUID();
                        const meta = {
                            id,
                            ownerId: state.userId,
                            name: encName,
                            type: encType,
                            thumbnail: encThumb,
                            timestamp: Date.now(),
                            size: file.size
                        };

                        await dbMgr.saveAsset(meta, encData);
                    }
                    ui.toast("保存完了");
                } catch (e) {
                    console.error("Upload Error:", e);
                    ui.toast("アップロードエラー");
                } finally {
                    input.value = "";
                    await app.refreshLibrary();
                    ui.loader(false);
                }
            },

            exportBackup: async () => {
                if (state.assets.length === 0) return ui.toast("保存するデータがありません");
                ui.loader(true, "バックアップ作成中...");
                try {
                    const tx = state.db.transaction([STORES.CONFIG, STORES.META, STORES.DATA], 'readonly');
                    const configKey = "cfg_" + state.userId;
                    const configReq = tx.objectStore(STORES.CONFIG).get(configKey);
                    
                    const config = await new Promise((resolve, reject) => {
                        configReq.onsuccess = () => resolve(configReq.result);
                        configReq.onerror = () => reject("Config read failed");
                    });

                    const assets = [];
                    for (let meta of state.assets) {
                        const content = await dbMgr.getContent(meta.id);
                        if (content) assets.push({ ...meta, data: content });
                    }

                    const backup = {
                        version: "v6",
                        userId: state.userId,
                        config: config,
                        assets: assets,
                        timestamp: Date.now()
                    };

                    const blob = new Blob([JSON.stringify(backup)], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `vault-backup-${new Date().toISOString().slice(0,10)}.json`;
                    a.click();
                    URL.revokeObjectURL(url);
                    ui.toast("バックアップを保存しました");
                } catch (e) {
                    console.error(e);
                    ui.toast("エクスポート失敗");
                } finally {
                    ui.loader(false);
                }
            },

            handleImport: async (input) => {
                const file = input.files[0];
                if (!file) return;
                
                ui.loader(true, "バックアップ読込中...");
                try {
                    const text = await file.text();
                    const backup = JSON.parse(text);
                    
                    if (!backup.assets || !backup.config) throw new Error("無効なフォーマットです");

                    // Restore Config
                    const txCfg = state.db.transaction(STORES.CONFIG, 'readwrite');
                    txCfg.objectStore(STORES.CONFIG).put(backup.config);
                    await new Promise(r => txCfg.oncomplete = r);

                    // Restore Assets
                    let count = 0;
                    const total = backup.assets.length;
                    
                    for (let item of backup.assets) {
                        count++;
                        ui.updateLoaderMsg(`資産データを復元中... (${count}/${total})`);
                        // Give UI chance to update
                        if (count % 5 === 0) await new Promise(r => setTimeout(r, 5));
                        
                        const content = item.data;
                        const meta = { ...item };
                        delete meta.data;
                        await dbMgr.saveAsset(meta, content);
                    }

                    alert("復元が完了しました。\n\n【重要】\nバックアップ作成時のパスワードでログインし直してください。");
                    location.reload();

                } catch (e) {
                    console.error(e);
                    ui.toast("インポート失敗: " + e.message);
                    ui.loader(false);
                }
                input.value = "";
            },

            openItem: async (id) => {
                if (state.isSelectionMode) return app.toggleSelect(id);
                viewer.currentIndex = state.assets.findIndex(a => a.id === id);

                ui.loader(true, "復号して開いています...");
                try {
                    await new Promise(r => setTimeout(r, 50));

                    const meta = state.assets.find(a => a.id === id);
                    const encContent = await dbMgr.getContent(id);
                    
                    if (!encContent) throw new Error("Data not found");

                    const decryptedData = await asyncCrypto('decrypt', encContent, state.key);
                    const decryptedType = await asyncCrypto('decrypt', meta.type, state.key);
                    const decryptedName = await asyncCrypto('decrypt', meta.name, state.key);
                    
                    await viewer.show(decryptedData, decryptedType, decryptedName);
                } catch(e) {
                    console.error("Open Error:", e);
                    ui.toast("ファイルを開けませんでした");
                } finally {
                    ui.loader(false);
                }
            },

            lock: () => {
                location.reload(); 
            },
            
            toggleSelect: (id) => {
                if (state.selected.has(id)) state.selected.delete(id);
                else state.selected.add(id);
                ui.updateSelectionUI();
            },
            
            deleteSelected: async () => {
                if(!confirm(`${state.selected.size} 件を削除しますか？`)) return;
                ui.loader(true, "削除中...");
                for(let id of state.selected) await dbMgr.deleteAsset(id);
                state.selected.clear();
                ui.toggleSelectionMode();
                await app.refreshLibrary();
                ui.loader(false);
            },

            filter: () => {
                const q = document.getElementById('searchInput').value.toLowerCase();
                const grid = document.getElementById('gridContainer');
                for (let card of grid.children) {
                    const name = card.dataset.name.toLowerCase();
                    card.style.display = name.includes(q) ? 'block' : 'none';
                }
            }
        };

        // --- UI ---
        const ui = {
            loader: (show, msg) => {
                const el = document.getElementById('globalLoader');
                if (msg) document.getElementById('loaderMsg').textContent = msg;
                el.style.display = show ? 'flex' : 'none';
            },
            updateLoaderMsg: (msg) => {
                document.getElementById('loaderMsg').textContent = msg;
            },
            toast: (msg) => {
                const t = document.getElementById('toast');
                t.textContent = msg;
                t.style.display = ''; 
                t.classList.remove('hidden');
                setTimeout(() => t.classList.add('hidden'), 3000);
            },
            showError: (msg) => {
                const input = document.getElementById('masterPass');
                input.classList.add('shake');
                ui.toast(msg);
                setTimeout(() => input.classList.remove('shake'), 400);
            },
            toggleCreateAccount: () => {
                document.getElementById('loginForm').classList.toggle('hidden');
                document.getElementById('createForm').classList.toggle('hidden');
            },
            renderGrid: async () => {
                const grid = document.getElementById('gridContainer');
                grid.innerHTML = '';
                
                if (state.assets.length === 0) {
                    document.getElementById('emptyState').classList.remove('hidden');
                    document.getElementById('itemCount').textContent = "0 Items";
                    document.getElementById('itemCountDisplay').textContent = "0 Items";
                    return;
                }
                document.getElementById('emptyState').classList.add('hidden');
                const countText = `${state.assets.length} Items`;
                document.getElementById('itemCount').textContent = countText;
                document.getElementById('itemCountDisplay').textContent = countText;

                for (let i = 0; i < state.assets.length; i++) {
                    const item = state.assets[i];
                    const el = document.createElement('div');
                    el.className = 'asset-card group';
                    el.dataset.id = item.id;
                    el.innerHTML = `
                        <div class="w-full h-full bg-slate-800 flex items-center justify-center text-slate-600 text-xs">
                            <span class="loading-text">...</span>
                        </div>
                        <img class="hidden w-full h-full object-cover">
                        <div class="absolute bottom-0 inset-x-0 bg-black/70 p-2 text-[10px] text-white truncate opacity-0 group-hover:opacity-100 transition-opacity">
                            <span class="name-text"></span>
                        </div>
                    `;
                    el.onclick = () => app.openItem(item.id);
                    grid.appendChild(el);

                    Promise.all([
                        asyncCrypto('decrypt', item.thumbnail, state.key),
                        asyncCrypto('decrypt', item.name, state.key)
                    ]).then(([thumbSrc, nameStr]) => {
                        const img = el.querySelector('img');
                        if (thumbSrc) {
                            img.src = thumbSrc;
                            img.classList.remove('hidden');
                            el.querySelector('.loading-text').parentElement.classList.add('hidden');
                        } else {
                            el.querySelector('.loading-text').textContent = "FILE";
                        }
                        el.querySelector('.name-text').textContent = nameStr;
                        el.dataset.name = nameStr;
                    }).catch(() => {
                        el.querySelector('.loading-text').textContent = "ERR";
                    });
                }
            },
            toggleSelectionMode: () => {
                state.isSelectionMode = !state.isSelectionMode;
                state.selected.clear();
                ui.updateSelectionUI();
                
                const btn = document.getElementById('selectBtn');
                btn.classList.toggle('text-indigo-400', state.isSelectionMode);
                document.getElementById('selectionActions').classList.toggle('hidden', !state.isSelectionMode);
            },
            updateSelectionUI: () => {
                for(let card of document.querySelectorAll('.asset-card')) {
                    if (state.selected.has(card.dataset.id)) card.classList.add('selected');
                    else card.classList.remove('selected');
                }
            },
            closeViewer: () => {
                document.getElementById('viewer').classList.add('hidden');
                document.getElementById('viewerContainer').innerHTML = '';
                viewer.stopIdleTimer(); 
            }
        };

        const viewer = {
            rotation: 0,
            currentIndex: 0,
            idleTimer: null,
            
            show: async (data, type, name) => {
                const con = document.getElementById('viewerContainer');
                con.innerHTML = '';
                document.getElementById('viewerFileName').textContent = name;
                viewer.rotation = 0;
                
                if (type.startsWith('image')) {
                    const img = new Image();
                    img.src = data;
                    img.className = 'viewer-content';
                    con.appendChild(img);
                } else if (type === 'application/pdf') {
                    const wrapper = document.createElement('div');
                    wrapper.className = 'pdf-wrapper';
                    con.appendChild(wrapper);
                    
                    try {
                        const pdfData = atob(data.split(',')[1]);
                        const bytes = new Uint8Array(pdfData.length);
                        for (let i = 0; i < pdfData.length; i++) bytes[i] = pdfData.charCodeAt(i);

                        const loadingTask = pdfjsLib.getDocument({
                            data: bytes,
                            cMapUrl: CMAP_URL,
                            cMapPacked: true
                        });
                        const pdf = await loadingTask.promise;
                        
                        for (let pageNum = 1; pageNum <= pdf.numPages; pageNum++) {
                            const page = await pdf.getPage(pageNum);
                            const viewport = page.getViewport({scale: 1.5});
                            const canvas = document.createElement('canvas');
                            canvas.className = 'pdf-page';
                            const context = canvas.getContext('2d');
                            canvas.height = viewport.height;
                            canvas.width = viewport.width;
                            
                            wrapper.appendChild(canvas);
                            
                            await page.render({
                                canvasContext: context,
                                viewport: viewport
                            }).promise;
                        }
                    } catch(e) {
                        console.error(e);
                        wrapper.innerHTML = '<p class="text-white">PDF表示エラー</p>';
                    }
                }
                document.getElementById('viewer').classList.remove('hidden');
                viewer.resetIdleTimer();
            },
            
            rotate: () => {
                viewer.rotation = (viewer.rotation + 90) % 360;
                const content = document.querySelector('.viewer-content') || document.querySelector('.pdf-wrapper');
                if (content) {
                    content.style.transform = `rotate(${viewer.rotation}deg)`;
                }
                viewer.resetIdleTimer();
            },

            nav: (dir) => {
                viewer.resetIdleTimer();
                if (state.assets.length <= 1) return;
                const len = state.assets.length;
                let newIdx = (viewer.currentIndex + dir);
                if (newIdx < 0) newIdx = len - 1;
                if (newIdx >= len) newIdx = 0;
                
                const nextAsset = state.assets[newIdx];
                app.openItem(nextAsset.id);
            },

            resetIdleTimer: () => {
                const viewerEl = document.getElementById('viewer');
                viewerEl.classList.remove('idle');
                clearTimeout(viewer.idleTimer);
                viewer.idleTimer = setTimeout(() => {
                    if (!viewerEl.classList.contains('hidden')) {
                        viewerEl.classList.add('idle');
                    }
                }, 2000); 
            },

            stopIdleTimer: () => {
                clearTimeout(viewer.idleTimer);
                document.getElementById('viewer').classList.remove('idle');
            }
        };

        const utils = {
            createThumb: (src) => {
                return new Promise(resolve => {
                    const img = new Image();
                    img.onload = () => {
                        const cvs = document.createElement('canvas');
                        const dim = 200;
                        let w = img.width, h = img.height;
                        if (w > h) { h = h * (dim/w); w = dim; } else { w = w * (dim/h); h = dim; }
                        cvs.width = w; cvs.height = h;
                        cvs.getContext('2d').drawImage(img, 0, 0, w, h);
                        resolve(cvs.toDataURL('image/jpeg', 0.5));
                    };
                    img.src = src;
                });
            },
            createPDFThumb: async (dataUrl) => {
                try {
                    const pdfData = atob(dataUrl.split(',')[1]);
                    const bytes = new Uint8Array(pdfData.length);
                    for (let i = 0; i < pdfData.length; i++) bytes[i] = pdfData.charCodeAt(i);

                    const loadingTask = pdfjsLib.getDocument({
                        data: bytes,
                        cMapUrl: CMAP_URL,
                        cMapPacked: true
                    });
                    const pdf = await loadingTask.promise;
                    const page = await pdf.getPage(1);
                    const viewport = page.getViewport({ scale: 0.5 });
                    const canvas = document.createElement('canvas');
                    const context = canvas.getContext('2d');
                    canvas.height = viewport.height;
                    canvas.width = viewport.width;
                    await page.render({ canvasContext: context, viewport: viewport }).promise;
                    return canvas.toDataURL('image/jpeg', 0.6);
                } catch(e) { console.error(e); return ""; }
            }
        };

        // --- GLOBAL EVENTS FOR IDLE TIMER ---
        ['mousemove', 'touchstart', 'click', 'keydown'].forEach(evt => {
            document.addEventListener(evt, () => {
                if (!document.getElementById('viewer').classList.contains('hidden')) {
                    viewer.resetIdleTimer();
                }
            });
        });

        // --- KEYBOARD SHORTCUTS ---
        document.addEventListener('keydown', e => {
            const viewerEl = document.getElementById('viewer');
            const isViewerOpen = !viewerEl.classList.contains('hidden');
            if (isViewerOpen) {
                if (e.key === 'ArrowLeft') viewer.nav(-1);
                if (e.key === 'ArrowRight') viewer.nav(1);
                if (e.key === 'Escape') ui.closeViewer();
            } else {
                if (e.key === 'Escape') app.lock();
            }
        });

        // Init
        app.init();

    </script>
</body>
</html>